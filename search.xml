<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android知识体系（三）--四大组件之ContentProvider]]></title>
      <url>%2F2019%2F01%2F11%2FAndroid%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%88%E5%9B%9B%EF%BC%89--%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BContentProvider%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android知识体系（三）--四大组件之BroadcastReceiver]]></title>
      <url>%2F2019%2F01%2F11%2FAndroid%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89--%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BBroadcastReceiver%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android知识体系（二）--四大组件之Service]]></title>
      <url>%2F2019%2F01%2F11%2FAndroid%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%88%E4%BA%8C%EF%BC%89--%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BService%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android知识体系（一）--四大组件之Activity]]></title>
      <url>%2F2019%2F01%2F11%2FAndroid%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%88%E4%B8%80%EF%BC%89--%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android之APK瘦身浅谈]]></title>
      <url>%2F2017%2F11%2F22%2Freduce_apk%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 APK结构在知道如何为APK瘦身前，我们需要先了解APK的结构，然后根据其组成部分进行优化处理。在Android Studio工具栏里，打开build–&gt;Analyze APK, 选择要分析的APK。 从上面图片中可以看出占用空间的主要是lib、res、assets、代码等，那么我们主要方向则应该精简代码、压缩图片、去除无用的库和资源文件。精简代码则要求开发者具有较高的编码素养和良好的编码习惯，同时也可能优化代码之后对APK大小不会有明细的改善，那接下来则介绍几种立竿见影的方法。 压缩图片通常情况下，从UI设计师那里获得的切图都是mipmap-hdpi、mipmap-xhdpi、mipmap-xxhdpi等几套不同分辨率的，通常情况下我们选择使用xhdpi或者xxhdpi一套资源图，即可满足大部分Android分辨率的手机。同时进行图片压缩，可以大大减少图片资源的占用大小。 推荐使用tinypng、智图 使用Vector Asset代替图片资源Vector的优势Google在发布Android 5.0时，提供了Vector矢量图的支持，VectorDrawable相对于普通的Drawable来说，有以下几个好处： Vector矢量图可以自动进行适配，不需要通过分辨率来设置不同的图片 Vector矢量图可以大幅减少图像的体积，同样一张图，用Vector来实现，可能只有PNG的几十分之一 使用简单，很多设计工具，都可以直接导出SVG图像，从而转换成Vector矢量图 功能强大，少量代码即可实现复杂炫酷的动画 成熟、稳定，前端已经非常广泛的进行使用了 在Android中的使用Android Studio提供了两种创建Vector资源的方式: 使用Material Icon 使用Local file(SVG,PSD) 在Android Studio工具栏里，File-&gt;New-&gt;Vector Asset 如果需要对5.0之前版本进行兼容的话，还需引用AppCompat 23.2及以上 1com.android.support:appcompat-v7:23.2.0 本文主要讲解使用Vector Asset来代替PNG图片，至于其动画等进阶用法，本文不做详细讲解。 这里需要解释下这里的几个标签： android:width :定义图片的宽 android:height:定义图片的高 android:viewportWidth:定义图像宽被划分的比例大小 android:viewportHeight :定义图像高被划分的比例大小 1例如例子中的24，即把24dp大小的图像划分成24份，后面Path标签中的坐标，就全部使用的是这里划分后的坐标系统。这样的好处，就是将图像大小与图像分离，我们可以随意修改图像大小，而不需要修改PathData中的坐标。 android:fillColor:图片填充颜色 android:pathData中的这些属性与Canvas绘图的属性基本类似。12345678910M = moveto(M X,Y) ：将画笔移动到指定的坐标位置L = lineto(L X,Y) ：画直线到指定的坐标位置H = horizontal lineto(H X)：画水平线到指定的X坐标位置V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝赛曲线S = smooth curveto(S X2,Y2,ENDX,ENDY)Q = quadratic Belzier curve(Q X,Y,ENDX,ENDY)：二次贝赛曲线T = smooth quadratic Belzier curveto(T ENDX,ENDY)：映射A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线Z = closepath()：关闭路径 去除无用资源在gradle使用minifyEnabled进行Proguard混淆，关于如何进行混淆，本文不做讲解。 1234567android &#123; buildTypes &#123; release &#123; minifyEnabled true &#125; &#125;&#125; 在gradle使用shrinkResources去除无用资源。另外我们也可以在AndroidStudio的菜单中选择Analyze-&gt;Inspecting Code进入Lint工具分析，查找未使用的图片资源 ，在结果列表中找到Unused resource这一栏，里面显示的都是未使用的资源列表，可以参照该信息手动删除资源。 123456android &#123; buildTypes &#123; release &#123; shrinkResources true &#125; &#125;&#125; 在gradle使用resConfigs设置去除无用的语言资源。例如下面的代码就只保留了中文和英文的语言资源： 12345android &#123; defaultConfig &#123; resConfigs &quot;zh&quot; ,&quot;en&quot; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[即时通讯技术资料分类]]></title>
      <url>%2F2017%2F08%2F15%2Fim%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 网络编程基础资料 第11章·UDP：用户数据报协议 第17章·TCP：传输控制协议 第18章·TCP连接的建立与终止 第21章·TCP的超时与重传 理论经典：TCP协议的3次握手与4次挥手过程详解 理论联系实际：Wireshark抓包分析TCP 3次握手、4次挥手过程 计算机网络通讯协议关系图（中文珍藏版） NAT详解：基本原理、穿越技术(P2P打洞)、端口老化等 UDP中一个包的大小最大能多大？ Java新一代网络编程模型AIO原理及Linux系统AIO介绍 NIO框架入门(三)：iOS与MINA2、Netty4的跨平台UDP双向通信实战 NIO框架入门(四)：Android与MINA2、Netty4的跨平台UDP双向通信实战 更多同类文章 有关IM/推送的通信格式、协议的选择 为什么QQ用的是UDP协议而不是TCP协议? 移动端即时通讯协议选择：UDP还是TCP？ 如何选择即时通讯应用的数据传输格式 强列建议将Protobuf作为你的即时通讯应用数据传输格式 移动端IM开发需要面对的技术问题（含通信协议选择） 简述移动端IM开发的那些坑：架构设计、通信协议和客户端 理论联系实际：一套典型的IM通信协议设计详解 58到家实时消息系统的协议设计等技术实践分享 更多同类文章 …… 有关IM/推送的心跳保活处理 Android进程保活详解：一篇文章解决你的所有疑问 Android端消息推送总结：实现原理、心跳保活、遇到的问题等 为何基于TCP协议的移动端IM仍然需要心跳保活机制？ 微信团队原创分享：Android版微信后台保活实战分享(进程保活篇) 微信团队原创分享：Android版微信后台保活实战分享(网络保活篇) 移动端IM实践：实现Android版微信的智能心跳机制 移动端IM实践：WhatsApp、Line、微信的心跳策略分析 更多同类文章 有关WEB端即时通讯开发 新手入门贴：史上最全Web端即时通讯技术原理详解 Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE SSE技术详解：一种全新的HTML5服务器推送事件技术 Comet技术详解：基于HTTP长连接的Web端实时通信技术 WebSocket详解（一）：初步认识WebSocket技术 socket.io实现消息推送的一点实践及思路 更多同类文章 有关IM架构设计 浅谈IM系统的架构设计 简述移动端IM开发的那些坑：架构设计、通信协议和客户端 一套原创分布式即时通讯(IM)系统理论架构方案 从零到卓越：京东客服即时通讯系统的技术架构演进历程 蘑菇街即时通讯/IM服务器开发之架构选择 腾讯QQ1.4亿在线用户的技术挑战和架构演进之路PPT 微信技术总监谈架构：微信之道——大道至简(演讲全文) 如何解读《微信技术总监谈架构：微信之道——大道至简》 快速裂变：见证微信强大后台架构从0到1的演进历程（一） 17年的实践：腾讯海量产品的技术方法论 更多同类文章 有关IM安全的文章： 即时通讯安全篇（一）：正确地理解和使用Android端加密算法 即时通讯安全篇（二）：探讨组合加密算法在IM中的应用 即时通讯安全篇（三）：常用加解密算法与通讯安全讲解 即时通讯安全篇（四）：实例分析Android中密钥硬编码的风险 传输层安全协议SSL/TLS的Java平台实现简介和Demo演示 理论联系实际：一套典型的IM通信协议设计详解（含安全层设计） 微信新一代通信安全解决方案：基于TLS1.3的MMTLS详解 来自阿里OpenIM：打造安全可靠即时通讯服务的技术实践分享 更多同类文章 有关实时音视频开发： 即时通讯音视频开发（一）：视频编解码之理论概述 即时通讯音视频开发（二）：视频编解码之数字视频介绍 即时通讯音视频开发（三）：视频编解码之编码基础 即时通讯音视频开发（四）：视频编解码之预测技术介绍 即时通讯音视频开发（五）：认识主流视频编码技术H.264 即时通讯音视频开发（六）：如何开始音频编解码技术的学习 即时通讯音视频开发（七）：音频基础及编码原理入门 即时通讯音视频开发（八）：常见的实时语音通讯编码标准 即时通讯音视频开发（九）：实时语音通讯的回音及回音消除概述 即时通讯音视频开发（十）：实时语音通讯的回音消除技术详解 即时通讯音视频开发（十一）：实时语音通讯丢包补偿技术详解 即时通讯音视频开发（十二）：多人实时音视频聊天架构探讨 即时通讯音视频开发（十三）：实时视频编码H.264的特点与优势 即时通讯音视频开发（十四）：实时音视频数据传输协议介绍 即时通讯音视频开发（十五）：聊聊P2P与实时音视频的应用情况 即时通讯音视频开发（十六）：移动端实时音视频开发的几个建议 即时通讯音视频开发（十七）：视频编码H.264、V8的前世今生 简述开源实时音视频技术WebRTC的优缺点 良心分享：WebRTC 零基础开发者教程（中文） 更多同类文章 IM开发综合文章 移动端IM开发需要面对的技术问题 开发IM是自己设计协议用字节流好还是字符流好？ 请问有人知道语音留言聊天的主流实现方式吗？ IM系统中如何保证消息的可靠投递（即QoS机制） 谈谈移动端 IM 开发中登录请求的优化 完全自已开发的IM该如何设计“失败重试”机制？ 微信对网络影响的技术试验及分析（论文全文） 即时通讯系统的原理、技术和应用（技术论文） 开源IM工程“蘑菇街TeamTalk”的现状：一场有始无终的开源秀 更多同类文章 开源移动端IM技术框架资料 开源移动端IM技术框架MobileIMSDK：快速入门 开源移动端IM技术框架MobileIMSDK：常见问题解答 开源移动端IM技术框架MobileIMSDK：压力测试报告 开源移动端IM技术框架MobileIMSDK：Android版Demo使用帮助 开源移动端IM技术框架MobileIMSDK：Java版Demo使用帮助 开源移动端IM技术框架MobileIMSDK：iOS版Demo使用帮助 开源移动端IM技术框架MobileIMSDK：Android客户端开发指南 开源移动端IM技术框架MobileIMSDK：Java客户端开发指南 开源移动端IM技术框架MobileIMSDK：iOS客户端开发指南 开源移动端IM技术框架MobileIMSDK：Server端开发指南 更多同类文章 有关推送技术的文章 iOS的推送服务APNs详解：设计思路、技术原理及缺陷等 Android端消息推送总结：实现原理、心跳保活、遇到的问题等 扫盲贴：认识MQTT通信协议 一个基于MQTT通信协议的完整Android推送Demo 求教android消息推送：GCM、XMPP、MQTT三种方案的优劣 移动端实时消息推送技术浅析 扫盲贴：浅谈iOS和Android后台实时消息推送的原理和区别 绝对干货：基于Netty实现海量接入的推送服务技术要点 移动端IM实践：谷歌消息推送服务(GCM)研究（来自微信） 为何微信、QQ这样的IM工具不使用GCM服务推送消息？ 更多同类文章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[摄影]]></title>
      <url>%2F2017%2F01%2F23%2Fphotography%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 新手进阶班 如何才能得到理想的曝光新手进阶班 构图到底是怎么一回事儿？别信老法师！解密那些不靠谱的摄影常识相机急救指南 快速搞定摄影入门常见问题 M档：手动，拨动转轮，调整曝光时间，长按“+/-”，拨动转轮，调整光圈；A档：光圈优先，自动曝光，拨动转轮，调整光圈，长按“+/-”，拨动转轮，调整曝光补偿；S档：曝光优先，自动调整光圈，拨动转轮，调整曝光时间，长按“+/-”，拨动转轮，调整曝光补偿；P档：自动，长按“+/-”，拨动转轮，调整曝光补偿。 光圈：F值越小，光圈越大，景深越小，背景越模糊。安全快门：安全快门= (1 / 焦距) 秒，因此焦距越长，安全快门的要求便越高，例如用上200mm 的焦距，安全快门便是1/200秒了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《每周一记》Android之Activity的生命周期和启动模式]]></title>
      <url>%2F2017%2F01%2F03%2Flifecycle_and_launchmode_of_activity%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 Activity作为Android四大组件之首，它的生命周期和启动模式在平时的开发中，重要而又常见，很多同学认为Activity的生命周期太简单而忽略了它的重要性，熟练的掌握相关知识，对于Activity的灵活运用会有很大的帮助。 1、Activity的生命周期详情：官方地址 Tips: Activity采用透明主题时，不会回调onStop 旋转屏幕使Activity不会重新创建的方法：android:configChanges=”orientation|keyboardHidden|screenSize” 2、Activity的启动模式2.1 Activity的LaunchMode有时候为了满足项目特殊需求，我们就必须使用Activity的启动模式，下面将简单的介绍一下四种启动模式:standard、singleTop、singleTask、singleInstance。 这些模式分为两大类，“standard”和“singleTop”Activity 为一类，“singleTask”和“singleInstance”为另一类。前两者启动模式的Activity可以被实例化多次。 standard：标准模式每次启动一个Activity都会创建一个新的实例 singleTop：栈顶复用模式如果目标任务的顶部已存在一个Activity实例则系统会通过调用该实例的onNewIntent()方法向其传送Intent，而不是创建新的Activity实例。 singleTask：栈内复用模式系统在新任务的根位置创建Activity并向其传送Intent。不过，如果已存在一个Activity实例，则系统会通过调用该实例的onNewIntent()方法向其传送Intent，而不是创建新的Activity实例，同时会将位于该实例顶部的其他实例全部移除出栈。此处将受TaskAffinity属性影响(用于指定Activity所关联的Task)，系统将查询是否有该Activity需要的任务栈，如果不存在，就会重新创建一个任务栈，然后创建Activity的实例；如果该任务栈已存在，则继续查询是否已存在该Activity的实例，如果不存在，则创建实例并放入栈中，如果存在，则将该实例顶部的其他实例全部推出栈。 singleInstance：单例模式与“singleTask””相同，只是系统不会将任何其他Activity启动到包含该实例的任务中。该Activity始终是其任务唯一仅有的成员。 2.1 Activity的FlagsActivity的Flags有很多，详情请查看官方文档，这里介绍几种比较常用的标记位。标记位的作用有很多，有的可以设定Activity的启动模式。 FLAG_ACTIVITY_NEW_TASK:为Activity指定“singleTask”启动模式 FLAG_ACTIVITY_SINGLE_TOP:相当于LauchMode中的singleTop。 FLAG_ACTIVITY_CLEAR_TOP:在同一个任务栈中所有位于它上面的Activity都要出栈。这个标记位一般都singleTask启动模式一起出现，在这种情况下，被动的Activity的实例如果已经存在，系统就会调用它的onNewIntent。如果被启动的Activity采用standard启动模式，那么它连同它之上的Activity都要出栈，系统会创建新的实例并放入栈顶。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS:具有这个标记位的Activity不会出现在历史Activity的列表中，如果调出的Activtivity只是一个功能片段，并没有实际的意义，此时长按Home键调出最近使用过的程序类表中，将不会出现此Activity。 FLAG_ACTIVITY_NO_HISTORY:使用这个FLAG启动的Activity，一旦退出，它不会存在于栈中，比如说，原来是A,B,C这个时候在C中以这个FLAG启动D的，D再启动E，这个时候栈中情况为A,B,C,E。 2.3 LaunchMode和Flags的运用设置Activity启动模式的两种方法： 通过在AndroidMenifest.xml中设置： 1234&lt;activity android:name=&quot;.ui.activity.MainActivity&quot; android:screenOrientation=&quot;portrait&quot; android:launchMode=&quot;singleTask&quot;/&gt; 通过Intent设置标志位 123Intent intent = new Intent(this,MainActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 以上两种方式都可以为Activity设置启动模式，当两者同时存在时，将以第二种为准，第一种方式无法直接为Activity设定FLAG_ACTIVITY_CLEAR_TOP标识，而第二种则无法为Activity指定singleInstance模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo在Github上搭建专属博客之技术总结]]></title>
      <url>%2F2017%2F01%2F01%2Fuse_HEXO_to_build_a_technical_blog_on_Github%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 一直想有一个专属的可以写文章的地方，作为一个初级程序员，记录一下工作中解决的难题，写一些知识点的总结，我相信这对自己的提升是相当有益的。之前同事有推荐使用Hexo在Github上部署静态博客，由于自己只是粗略的浏览了一下，觉得太麻烦，便转向拥抱了简书。不过在后来的使用中，越发的感受到了它的局限性，所以有了搭建自己博客的想法，当然我同样会继续使用简书，毕竟它里面有很多优秀的文章。 前言：网上已经有很多的教程，这里便不再赘述，本文主要是记录这次部署静态博客的经验和遇到的一些问题。在使用这些第三方工具的时候，貌似我们的第一反应就是Google教程，而忽略了其官方使用文档，所以笔者还是建议大家直接查看官网吧。 官方网址Node.js官网Hexo官网Git官网 推荐教程：如何搭建一个独立博客——简明Github Pages与Hexo教程2小时用hexo搭建个人博客 推荐主题：Themes汇总HuxproNextFexo 正文：实践出真理，在官网和教程已经阐述得很详尽的情况下，也难免不会出现任何问题，只有自己亲手去做了，才能理解其奥秘。其实本人对终端命令知之甚少，在这次搭建博客过程中，遇到不少问题，反而促使自己去寻找解决方案，在这个过程学到不少东西，或许这就是其中乐趣所在吧。 使用淘宝镜像安装Hexo失败（若提示没有权限，请使用sudo命令）1$ npm install -g hexo-cli 解决办法：1$ npm install cnpm -g --registry=https://registry.npm.taobao.org 修改项目目录的_config.yml一开始我把repo设值为Github上ssh的地址，导致一直报ssh不匹配的错误，折腾了很久，自己把自己坑哭了。 1234deploy: type: git repo: https://github.com/Rickwan/Rickwan.github.io.git branch: master 提示“FATAL Port 4000 has been used. Try other port instead.”在使用了$ hexo s命令预览博客效果后使用Control+C关闭解决办法： 1$ sudo hexo s -p 5000 提示“ERROR Deployer not found: git”解决办法： 1$ sudo npm install hexo-deployer-git --save 发布 123$ sudo hexo clean$ sudo hexo g$ sudo hexo d 至此，利用Hexo在Github上部署静态博客就成功啦。 小技能： 终端返回上一级目录： 1$ cd .. git相关：查看git配置信息： 1$ git config --list 设置git账号：12$ git config --global user.name [username]$ git config --global user.email [email] ssh相关：查看ssh1$ open ~/.ssh 生成ssh -key:1$ ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《每周一记》之Android软键盘]]></title>
      <url>%2F2016%2F12%2F31%2FWindowSoftInputMode_of_android%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 在以往的项目开发中，关于软键盘的知识点一直比较模糊，只是知道简单的使用，当遇到问题的时候，也只能靠度娘或者蒙，刚好最近一个同事询问相关问题时，才发现自己知识的薄弱，正好以此来激励自己不断学习。这也正是这边文章的诞生的原因，更是让我决定开始记录《每周一记》。 参考：官方文档 一、WindowSoftInputMode属性活动的主窗口如何与包含屏幕上的软键盘窗口交互,这个属性的设置将会影响两件事情: 软键盘的状态:当活动(Activity)成为用户关注的焦点时，它是否隐藏或显示。 对活动主窗口进行的调整：无论是调整大小以便为软键盘腾出空间，还是在软键盘覆盖窗口的一部分，以便当前焦点内容可见。 How the main window of the activity interacts with the window containing the on-screen soft keyboard. The setting for this attribute affects two things: The state of the soft keyboard — whether it is hidden or visible — when the activity becomes the focus of user attention. The adjustment made to the activity’s main window — whether it is resized smaller to make room for the soft keyboard or whether its contents pan to make the current focus visible when part of the window is covered by the soft keyboard. 1、属性详解The setting must be one of the values listed in the following table, or a combination of one “state…” value plus one “adjust…” value. Setting multiple values in either group — multiple “state…” values, for example — has undefined results. Individual values are separated by a vertical bar (|). For example: 1&lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; . . . &gt; 此处设置的值（“stateUnspecified”和“adjustUnspecified”除外）将覆盖主题中设置的值。 Values set here (other than “stateUnspecified” and “adjustUnspecified”) override values set in the theme. 用来设置窗口软键盘的交互模式，其属性一共有9个取值，分别是：stateUnspecified，stateUnchanged，stateHidden，stateAlwaysHidden，stateVisible，stateAlwaysVisible，adjustUnspecified，adjustResize，adjustPan。 stateUnspecified默认交互方式，系统会根据界面采取相应的软键盘的显示模式。比如，当界面上只有输入框和按钮的时候，软键盘就不会自动弹出，但是当有获得焦点的输入框的界面有滚动的需求的时候，会自动弹出软键盘，例如外层为ScrollView。阻止键盘弹出的一个解决方案就是，在xml文件中，设置一个非输入框控件获取焦点。The state of the soft keyboard (whether it is hidden or visible) is not specified. The system will choose an appropriate state or rely on the setting in the theme.This is the default setting for the behavior of the soft keyboard. stateUnchanged保持当前软键盘状态不变。举个例子，假如当前界面键盘是隐藏的，那么跳转之后的界面，软键盘也是隐藏的；如果当前界面是显示的，那么跳转之后的界面，软键盘也是显示状态。The soft keyboard is kept in whatever state it was last in, whether visible or hidden, when the activity comes to the fore. stateHidden当用户导航到而不是返回到该activity时，软键盘总是被隐藏。The soft keyboard is hidden when the user chooses the activity — that is, when the user affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity. stateAlwaysHidden当Activity的主窗口拥有输入焦点时，软键盘总是被隐藏。The soft keyboard is always hidden when the activity’s main window has input focus. stateVisible强制打开软键盘。The soft keyboard is visible when that’s normally appropriate (when the user is navigating forward to the activity’s main window). stateAlwaysVisibleThe soft keyboard is made visible when the user chooses the activity — that is, when the user affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity. adjustUnspecified设置软键盘与软件的显示内容之间的显示关系，默认的设置模式。在这中情况下，系统会根据界面选择不同的模式。如果界面里面有可以滚动的控件，比如ScrowView，系统会减小可以滚动的界面的大小，从而保证即使软键盘显示出来了，也能够看到所有的内容。如果布局里面没有滚动的控件，那么软键盘可能就会盖住一些内容。没有滚动控件，软键盘下面的布局都被遮挡住，若想修改，只能隐藏软键盘，然后选择。而且，重点注意一下上面的布局，当我们选择的输入框偏下的时候，上面的标题栏和布局被软键盘顶上去了。It is unspecified whether the activity’s main window resizes to make room for the soft keyboard, or whether the contents of the window pan to make the current focus visible on-screen. The system will automatically select one of these modes depending on whether the content of the window has any layout views that can scroll their contents. If there is such a view, the window will be resized, on the assumption that scrolling can make all of the window’s contents visible within a smaller area.This is the default setting for the behavior of the main window. adjustResize(压缩模式)这个属性表示Activity的主窗口总是会被调整大小，从而保证软键盘显示空间。The activity’s main window is always resized to make room for the soft keyboard on screen. adjustPan(平移模式)如果设置为这个属性，那么Activity的屏幕大小并不会调整来保证软键盘的空间，而是采取了另外一种策略，系统会通过布局的移动，来保证用户要进行输入的输入框肯定在用户的视野范围内，从而让用户可以看到自己输入的内容。对于没有滚动控件的布局来说，这个其实就是默认的设置，如果我们选择的位置偏下，上面的标题栏和部分控件会被顶上去。The activity’s main window is not resized to make room for the soft keyboard. Rather, the contents of the window are automatically panned so that the current focus is never obscured by the keyboard and users can always see what they are typing. This is generally less desirable than resizing, because the user may need to close the soft keyboard to get at and interact with obscured parts of the window. 备注：如果我们不设置”adjust…”的属性，对于没有滚动控件的布局来说，采用的是adjustPan方式，而对于有滚动控件的布局，则是采用的adjustResize方式。 2、使用方式 代码实现方式： 12 //在activity中的setContentView之前写上以下代码getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); xml实现方式： 12//在 项目的AndroidManifest.xml文件中界面对应的&lt;activity&gt;里加入android:windowSoftInputMode=&quot;adjustPan&quot; 二、手动打开、关闭软键盘在开发过程中，难免会遇到想手动打开或者关闭软键盘的情况，这时使用以下代码不失为一种好办法。 123456789/** * 动态显示隐藏软键盘 * * @param context context */public static void toggleSoftInput(Context context) &#123; InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS);&#125; 三、软键盘的Enter键1、使用方式 当layout中有多个EditText，把每个控件的android:singleLine的属性都被设置成true的情况下，软键盘的Enter键上 的文字会变成“Next”，按下后下个EditText会自动获得焦点（实现了“Next”的功能）；当最后一个控件获得焦点的时候，Enter键上的文 字会变成“Done”，按下后软键盘会自动隐藏起来。 把EditText的ImeOptions属性设置成不同的值，Enter键上可以显示不同的文字或图案actionNone : 回车键，按下后光标到下一行actionGo ： Go，actionSearch ： 一个放大镜actionSend ： SendactionNext ： NextactionDone ： Done，隐藏软键盘，即使不是最后一个文本输入框 12345678910inputView.setImeOptions(EditorInfo.IME_ACTION_SEARCH);editText.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123; public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_SEARCH || (event != null &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_ENTER)) &#123; //do something; return true; &#125; return false; &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android之DownloadManager实现软件更新并自动安装]]></title>
      <url>%2F2016%2F12%2F31%2Fupdate_apk_by_downloadmanager%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 在Android开发中，软件更新可以说是必不可少的，而隔壁的iOS喝着咖啡，无情的嘲笑着这个他们不用再实现的功能，因为苹果会无情的拒绝所有包含软件更新，哪怕是版本检测的APP。作为苦逼的Android攻城狮，我们还是老老实实地研究一下如何实现软件更新吧。 一、软件升级的实现思路 下载APK 应用内下载文件应用内实现文件下载，如果退出程序，下载将结束。 Service下载文件利用Service实现文件后台下载，不受程序是否退出的影响。 安装APK 手动安装 自动安装 对于用户而言，后台下载并自动安装必然是一个好的使用体验。使用Service去实现文件下载的话，还需要我们自己维护网络请求，这可是非常麻烦又头痛的事情，有没有一个更方便快捷的方式呢？下面将介绍一种简单粗暴的实现方法！ 二、DownloadManager实现文件下载 使用DownloadManager实现APK下载通过DownloadManager来实现文件下载，我们就可以完全不用考虑网络请求、异步问题了，系统帮我们处理了所有事情，你可以继续操作App，即便是退出程序也不会影响APK的下载。 1234567891011121314151617181920212223242526272829303132333435 /** * 下载新版本 * * @param context * @param url */public static void downLoadAPK(Context context, String url) &#123; if (TextUtils.isEmpty(url)) &#123; return; &#125; try &#123; String serviceString = Context.DOWNLOAD_SERVICE; final DownloadManager downloadManager = (DownloadManager) context.getSystemService(serviceString); Uri uri = Uri.parse(url); DownloadManager.Request request = new DownloadManager.Request(uri); request.allowScanningByMediaScanner(); request.setVisibleInDownloadsUi(true); request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); request.setMimeType(&quot;application/vnd.android.package-archive&quot;); File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath()+&quot;/juyoubang/&quot;,&quot;juyoubang.apk&quot;); if (file.exists())&#123; file.delete(); &#125; request.setDestinationInExternalPublicDir(Environment.getExternalStorageDirectory().getAbsolutePath()+&quot;/juyoubang/&quot;, &quot;juyoubang.apk&quot;); long refernece = downloadManager.enqueue(request); SharePreHelper.getIns().setLongData(&quot;refernece&quot;, refernece); &#125; catch (Exception exception) &#123; ToastUtils.init(context).show(&quot;更新失败&quot;); &#125; &#125; 三、自动安装这里的自动安装是指下载完成后，自动弹出安装界面，而不是静默安装APK。同时这里不得不提的一个大坑就是Android6.0这个分水岭，6.0以后的实现方式有所不同。 自定义Receiver接收系统广播，实现软件自动安装。Android6.0之前的版本我们可以通过Intent的方式来实现，但是我们会发现6.0之后的手机上，下载完成后没有任何效果，解决办法就是通过打开文件的形式实现自动安装。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class UpdataBroadcastReceiver extends BroadcastReceiver &#123; @SuppressLint(&quot;NewApi&quot;) public void onReceive(Context context, Intent intent) &#123; long myDwonloadID = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1); long refernece = SharePreHelper.getIns().getLongData(&quot;refernece&quot;, 0); if (refernece != myDwonloadID) &#123; return; &#125; DownloadManager dManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE); Uri downloadFileUri = dManager.getUriForDownloadedFile(myDwonloadID); installAPK(context,downloadFileUri); &#125; private void installAPK(Context context,Uri apk ) &#123; if (Build.VERSION.SDK_INT &lt; 23) &#123; Intent intents = new Intent(); intents.setAction(&quot;android.intent.action.VIEW&quot;); intents.addCategory(&quot;android.intent.category.DEFAULT&quot;); intents.setType(&quot;application/vnd.android.package-archive&quot;); intents.setData(apk); intents.setDataAndType(apk, &quot;application/vnd.android.package-archive&quot;); intents.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intents); &#125; else &#123; File file = queryDownloadedApk(context); if (file.exists()) &#123; openFile(file, context); &#125; &#125; &#125; /** * 通过downLoadId查询下载的apk，解决6.0以后安装的问题 * @param context * @return */ public static File queryDownloadedApk(Context context) &#123; File targetApkFile = null; DownloadManager downloader = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE); long downloadId = SharePreHelper.getIns().getLongData(&quot;refernece&quot;, -1); if (downloadId != -1) &#123; DownloadManager.Query query = new DownloadManager.Query(); query.setFilterById(downloadId); query.setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL); Cursor cur = downloader.query(query); if (cur != null) &#123; if (cur.moveToFirst()) &#123; String uriString = cur.getString(cur.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)); if (!TextUtils.isEmpty(uriString)) &#123; targetApkFile = new File(Uri.parse(uriString).getPath()); &#125; &#125; cur.close(); &#125; &#125; return targetApkFile; &#125; private void openFile(File file, Context context) &#123; Intent intent = new Intent(); intent.addFlags(268435456); intent.setAction(&quot;android.intent.action.VIEW&quot;); String type = getMIMEType(file); intent.setDataAndType(Uri.fromFile(file), type); try &#123; context.startActivity(intent); &#125; catch (Exception var5) &#123; var5.printStackTrace(); Toast.makeText(context, &quot;没有找到打开此类文件的程序&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; private String getMIMEType(File var0) &#123; String var1 = &quot;&quot;; String var2 = var0.getName(); String var3 = var2.substring(var2.lastIndexOf(&quot;.&quot;) + 1, var2.length()).toLowerCase(); var1 = MimeTypeMap.getSingleton().getMimeTypeFromExtension(var3); return var1; &#125;&#125; 最后记得在AndroidManifest.xml中注册广播 123456&lt;receiver android:name=&quot;.receiver.UpdataBroadcastReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.DOWNLOAD_COMPLETE&quot; /&gt; &lt;!--&lt;action android:name=&quot;android.intent.action.PACKAGE_INSTALL&quot; /&gt;--&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 还未实现功能：安装成功后删除apk文件。 大功告成。 小插曲：当我把文件名称”juyoubang.apk”写成静态常量来引用的时候，下载并安装时，会提示文件已损坏，无法安装，这让我百思不得其解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android之腾讯云乐固终端加固]]></title>
      <url>%2F2016%2F12%2F31%2Ffirm_apk_by_tencent%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 腾讯云乐固 一、腾讯云乐固终端加固 首先将需要加固的apk上传至腾讯云乐固，如下图所示，上传应用并完成加固; 加固完成后，进入应用详情，点击“下载加固包”下载已加固apk，如下图所示。 打开终端，输入以下命令行，点击回车，输入keystore密码，再次回车大功告成。jarsigner -verbose -keystore “keystorePath” -signedjar “signedPath” “unSignedPath” “alias” 二、命令行介绍 keystorePath：keystore路径 signedPath：签名后apk的储存路径 unSignedPath：未签名apk的储存路径 alias：keystore别名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android之JitPack快速发布开源库]]></title>
      <url>%2F2016%2F12%2F31%2Frelease_open_library_by_jitpack%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 JitPackJitPack Documentation Publish an Android libraryIn order to publish your Android library on JitPack you just need a working build file in your Git repository. Android SDK is available in the build environment and ANDROID_HOME variable is already set when the build starts. Builds are run with Java 8 by default but can be configured using a jitpack.yml file. GradleTo enable building on JitPack you need to add the android-maven plugin.If using Gradle 3.0 or later: In your root build.gradle: 123dependencies &#123; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.5&apos;&#125; In your library/build.gradle add: 12apply plugin: &apos;com.github.dcendents.android-maven&apos; group=&apos;com.github.YourUsername&apos; Create a GitHub release or add a git tag. Remark： Publish the project to Github and release it to the public repository Get the JitPack repository address Installing Users of your library will need add the jitpack.io repository: 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; And 123dependencies &#123; compile &apos;com.github.jitpack:android-example:1.0.1&apos;&#125; Note: do not add the jitpack.io repository under build script Demo]]></content>
    </entry>

    
  
  
</search>
