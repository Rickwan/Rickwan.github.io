<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android之DownloadManager实现软件更新并自动安装]]></title>
      <url>%2F2016%2F12%2F31%2FAndroid%E4%B9%8BDownloadManager%E5%AE%9E%E7%8E%B0%E8%BD%AF%E4%BB%B6%E6%9B%B4%E6%96%B0%E5%B9%B6%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 在Android开发中，软件更新可以说是必不可少的，而隔壁的iOS喝着咖啡，无情的嘲笑着这个他们不用再实现的功能，因为苹果会无情的拒绝所有包含软件更新，哪怕是版本检测的APP。作为苦逼的Android攻城狮，我们还是老老实实地研究一下如何实现软件更新吧。 一、软件升级的实现思路 下载APK 应用内下载文件应用内实现文件下载，如果退出程序，下载将结束。 Service下载文件利用Service实现文件后台下载，不受程序是否退出的影响。 安装APK 手动安装 自动安装 对于用户而言，后台下载并自动安装必然是一个好的使用体验。使用Service去实现文件下载的话，还需要我们自己维护网络请求，这可是非常麻烦又头痛的事情，有没有一个更方便快捷的方式呢？下面将介绍一种简单粗暴的实现方法！ 二、DownloadManager实现文件下载 使用DownloadManager实现APK下载通过DownloadManager来实现文件下载，我们就可以完全不用考虑网络请求、异步问题了，系统帮我们处理了所有事情，你可以继续操作App，即便是退出程序也不会影响APK的下载。 1234567891011121314151617181920212223242526272829303132333435 /** * 下载新版本 * * @param context * @param url */public static void downLoadAPK(Context context, String url) &#123; if (TextUtils.isEmpty(url)) &#123; return; &#125; try &#123; String serviceString = Context.DOWNLOAD_SERVICE; final DownloadManager downloadManager = (DownloadManager) context.getSystemService(serviceString); Uri uri = Uri.parse(url); DownloadManager.Request request = new DownloadManager.Request(uri); request.allowScanningByMediaScanner(); request.setVisibleInDownloadsUi(true); request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); request.setMimeType(&quot;application/vnd.android.package-archive&quot;); File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath()+&quot;/juyoubang/&quot;,&quot;juyoubang.apk&quot;); if (file.exists())&#123; file.delete(); &#125; request.setDestinationInExternalPublicDir(Environment.getExternalStorageDirectory().getAbsolutePath()+&quot;/juyoubang/&quot;, &quot;juyoubang.apk&quot;); long refernece = downloadManager.enqueue(request); SharePreHelper.getIns().setLongData(&quot;refernece&quot;, refernece); &#125; catch (Exception exception) &#123; ToastUtils.init(context).show(&quot;更新失败&quot;); &#125; &#125; 三、自动安装这里的自动安装是指下载完成后，自动弹出安装界面，而不是静默安装APK。同时这里不得不提的一个大坑就是Android6.0这个分水岭，6.0以后的实现方式有所不同。 自定义Receiver接收系统广播，实现软件自动安装。Android6.0之前的版本我们可以通过Intent的方式来实现，但是我们会发现6.0之后的手机上，下载完成后没有任何效果，解决办法就是通过打开文件的形式实现自动安装。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class UpdataBroadcastReceiver extends BroadcastReceiver &#123; @SuppressLint(&quot;NewApi&quot;) public void onReceive(Context context, Intent intent) &#123; long myDwonloadID = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1); long refernece = SharePreHelper.getIns().getLongData(&quot;refernece&quot;, 0); if (refernece != myDwonloadID) &#123; return; &#125; DownloadManager dManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE); Uri downloadFileUri = dManager.getUriForDownloadedFile(myDwonloadID); installAPK(context,downloadFileUri); &#125; private void installAPK(Context context,Uri apk ) &#123; if (Build.VERSION.SDK_INT &lt; 23) &#123; Intent intents = new Intent(); intents.setAction(&quot;android.intent.action.VIEW&quot;); intents.addCategory(&quot;android.intent.category.DEFAULT&quot;); intents.setType(&quot;application/vnd.android.package-archive&quot;); intents.setData(apk); intents.setDataAndType(apk, &quot;application/vnd.android.package-archive&quot;); intents.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intents); &#125; else &#123; File file = queryDownloadedApk(context); if (file.exists()) &#123; openFile(file, context); &#125; &#125; &#125; /** * 通过downLoadId查询下载的apk，解决6.0以后安装的问题 * @param context * @return */ public static File queryDownloadedApk(Context context) &#123; File targetApkFile = null; DownloadManager downloader = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE); long downloadId = SharePreHelper.getIns().getLongData(&quot;refernece&quot;, -1); if (downloadId != -1) &#123; DownloadManager.Query query = new DownloadManager.Query(); query.setFilterById(downloadId); query.setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL); Cursor cur = downloader.query(query); if (cur != null) &#123; if (cur.moveToFirst()) &#123; String uriString = cur.getString(cur.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)); if (!TextUtils.isEmpty(uriString)) &#123; targetApkFile = new File(Uri.parse(uriString).getPath()); &#125; &#125; cur.close(); &#125; &#125; return targetApkFile; &#125; private void openFile(File file, Context context) &#123; Intent intent = new Intent(); intent.addFlags(268435456); intent.setAction(&quot;android.intent.action.VIEW&quot;); String type = getMIMEType(file); intent.setDataAndType(Uri.fromFile(file), type); try &#123; context.startActivity(intent); &#125; catch (Exception var5) &#123; var5.printStackTrace(); Toast.makeText(context, &quot;没有找到打开此类文件的程序&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; private String getMIMEType(File var0) &#123; String var1 = &quot;&quot;; String var2 = var0.getName(); String var3 = var2.substring(var2.lastIndexOf(&quot;.&quot;) + 1, var2.length()).toLowerCase(); var1 = MimeTypeMap.getSingleton().getMimeTypeFromExtension(var3); return var1; &#125;&#125; 最后记得在AndroidManifest.xml中注册广播 123456&lt;receiver android:name=&quot;.receiver.UpdataBroadcastReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.DOWNLOAD_COMPLETE&quot; /&gt; &lt;!--&lt;action android:name=&quot;android.intent.action.PACKAGE_INSTALL&quot; /&gt;--&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 还未实现功能：安装成功后删除apk文件。 大功告成。 小插曲：当我把文件名称”juyoubang.apk”写成静态常量来引用的时候，下载并安装时，会提示文件已损坏，无法安装，这让我百思不得其解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android之腾讯云乐固终端加固]]></title>
      <url>%2F2016%2F12%2F31%2FAndroid%E4%B9%8B%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B9%90%E5%9B%BA%E7%BB%88%E7%AB%AF%E5%8A%A0%E5%9B%BA%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 腾讯云乐固 一、腾讯云乐固终端加固 首先将需要加固的apk上传至腾讯云乐固，如下图所示，上传应用并完成加固; 加固完成后，进入应用详情，点击“下载加固包”下载已加固apk，如下图所示。 打开终端，输入以下命令行，点击回车，输入keystore密码，再次回车大功告成。jarsigner -verbose -keystore “keystorePath” -signedjar “signedPath” “unSignedPath” “alias” 二、命令行介绍 keystorePath：keystore路径 signedPath：签名后apk的储存路径 unSignedPath：未签名apk的储存路径 alias：keystore别名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android之JitPack快速发布开源库]]></title>
      <url>%2F2016%2F12%2F31%2FAndroid%E4%B9%8BJitPack%E5%BF%AB%E9%80%9F%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%2F</url>
      <content type="text"><![CDATA[为之于未有，治之于未乱。 JitPackJitPack Documentation Publish an Android libraryIn order to publish your Android library on JitPack you just need a working build file in your Git repository. Android SDK is available in the build environment and ANDROID_HOME variable is already set when the build starts. Builds are run with Java 8 by default but can be configured using a jitpack.yml file. GradleTo enable building on JitPack you need to add the android-maven plugin.If using Gradle 3.0 or later: In your root build.gradle: 123dependencies &#123; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.5&apos;&#125; In your library/build.gradle add: 12apply plugin: &apos;com.github.dcendents.android-maven&apos; group=&apos;com.github.YourUsername&apos; Create a GitHub release or add a git tag. Remark： Publish the project to Github and release it to the public repository Get the JitPack repository address Installing Users of your library will need add the jitpack.io repository: 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; And 123dependencies &#123; compile &apos;com.github.jitpack:android-example:1.0.1&apos;&#125; Note: do not add the jitpack.io repository under build script Demo]]></content>
    </entry>

    
  
  
</search>
